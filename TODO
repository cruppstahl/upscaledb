I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

-----------------------------------------------------------------------------
This Branch Is About Integrating The hamsterdb2 Functionality!!!!!
-----------------------------------------------------------------------------
The big headline is:
As a user i want to run many Transactions in parallel with high performance.
I'm using multiple threads b/c my CPU has multiple cores, and expect hamsterdb
to scale with the number of cores.
==============================================================================

high-level plan for 2.1.9 ..................................................
x new file system structure
x release sparsemap library w/ documentation and sample/tests
o update the webpage (free for non-profits, cheap for startups, add crc32)
o exception safe code
o lots of refactoring
o update file format (compress record IDs, UpfrontIndex, ...)
o delta updates

x PRO: 
    x fix bug as reported from Ole (mail from 26.)
    x also fix segfault during recovery
    x create new unittest from his sample

x PRO: use a bitmap index for recnos
    - nah...
    x but move the sparsemap library to github, as a seperate project
    x also write an accompanying blog post or documentation

x PRO: make the release

o PRO: webpage changes
    x add CRC32 to pro documentation, feature matrix
    o give away for free to non-profits
    o also add a startup program? or make it cheaper???

-------------------------------------------------------------

x faq: add documentation about library size: strip helps

x refactoring: split files
    x root0: add pragmas from btree_impl_default.h, undef min/max
    x create a template for the header files
    x document the source code structure

    x for each file, perform the following changes:
        x #34: header guards/macros should not clash with reserved identifiers
            (no leading/trailing underscores)
        x adapt to template.h, template.cc
        x make sure that the layers are respected (do not include n+1!)
        x classes without private or protected members should become structs

    x 0root/root.h - very first header file (only one!)
    x 1base/error.h, pack*, util, mutex, version, abi, pickle
    x 1globals/
    x 1errorinducer/
    x 1mem/
    x 1os/
    x 1rb/
    x 2page/
    x 2device/
    x 2protoserde/
    x 2protobuf/
    x 3changeset/
    x 3cache/
    x 3blob_manager/
    x 3journal/
    x 3page_manager/
    x 3btree/btree*
    x 4db/...
    x 4txn/...
    x 4env/...
    x 4cursor/...
    x 5server/...
    x 5hamsterdb/hamsterdb.cc, hola.cc
    x also cleanup unittests

x java still has license.java - remove!
    x also check dotnet!

x refactoring: split unittests/cursor.cpp - it does not compile on smaller VMs

x refactoring: #37 - hamzilla.c/running should be sig_atomic_t
    -> transform to c++ code

x can we add a generic macro like this:
    #define ham_make_key(PTR, SIZE)   { SIZE, PTR, 0, 0}
    which can be used as an initializer:
    ham_key_t key = ham_make_key("hello", 5);
    x same for records
    x use in samples
    x document in header file

x refactoring: get_linear_search_threshold returns size_t, but is
    then used as (signed) int; some return 0, others -1
    right now the code works but is cheesy. return (int)0 to disable.

x ham_bench/config.h: use iostream instead of printf to avoid compiler
    warnings on 32bit linux

x review exception safety
    http://exceptionsafecode.com/
    - consistently use smart_pointers to manage allocated resources!
        use boost::scoped_ptr (from <boost/scoped_ptr.hpp>)
    - introduce on_scope_exit macro
        can use BOOST_SCOPE_EXIT:
        http://www.boost.org/doc/libs/1_56_0/libs/scope_exit/doc/html/scope_exit/tutorial.html
    - consistently force use of RAII
    - every destructor has to clean up but MOST NOT THROW!
    - support std::swap
        http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-throwing_swap
    - manage state like a resource
        Each state is moved to a separate struct (ClassNameState). The class
        itself can return the struct as "const", and it has (in best case)
        a single method which performs write-access.
        Try to make the State-struct exception safe, whenever members
        are retrieved or overwritten.
    - use "critical line" for strong guarantees and defer commits till
        success is guaranteed
        -> this relates to the use of std::swap
    - every state has to be restored in case of an exception
    - document every rewritten class with an annotation ("@exception_safe yes")
        -> define rules
        @exception_safe [yes|no|unknown|nothrow]
        @thread_safe [no|unknown|atomic|blocking]
    x document the rules (coding guidelines)
    x document the annotations
    x add annotations to *each* file

x refactoring: split os.h in file.h and socket.h
    and upgrade File to "strong" exception safety

x refactoring: upgrade "device" to strong exception safety

x refactoring: upgrade "page" to strong exception safety
    x see TODOs in page.cc

x refactoring: improve layering
    x improve layer separation of device (remove dependency to env)
    x improve layer separation of page (remove dependency to env)
    x can we move cache to layer 2 or 3?

x refactoring: clean up the close() code of the LocalEnvironment (and also
    of the LocalDatabase). distinguish two cases:
    - a close() called by ham_env_close/ham_db_close
        performs logic that can fail; must not be exception safe
    - a close() called in the destructor
        do not perform any logic besides cleaning up; must NOT THROW!
        actually there shouldn't be a need to do anything if scoped_ptr
        is used consistently
    x use smart_ptr for all members of the LocalDatabase
        (m_txn_index, m_btree_index)
        x then make sure that the tests run again
    x ... and for the RemoteEnvironment (if required) - not required
    x ... and for the LocalEnvironment
        (m_header, m_blob_manager, m_page_manager, m_journal)

x see mail from Michael Möllney: journal files are not truncated if
    temporary transactions are used
    ./ham_bench --use-transactions=1 --key=uint64 --distribution=ascending --recsize=10241024
    x fix the bug
    x check Michael's mail - is an enum large enough for big values?
    x investigate why this was not discovered with the recovery.pl script
        x add larger records
        x check error inducer when flushing the changeset, not when
            filling it! this is critical. right now many of the INDUCE
            invocations are ignored!
        x still not reproducible - wtf? make sure that the inducer in
            journal.h is triggered - it is
        x also, the bugfix was reverted to make sure that it's covered
            by the tests
    x what are the possible states during recovery?
        invariant: a changeset flushes all committed transactions.
        in other word: after a changeset was flushed, only active
            transactions remain.
        x last changeset is valid, gets applied, no newer transactions
            x add a test
        x last changeset is valid, gets applied, but newer transactions must be
            recreated
            x add a test
        x last changeset is valid, but after it's applied an existing txn
            is committed:
            t1 = txn_begin
            insert(t1)
            for (i : [0..64))
                t2 = txn_begin
                insert(t2)
                txn_commit(t2)
            # changeset flush happens here
            insert(t1)
            txn_commit(t1)
            -> changeset is never flushed! why?? because txn's can only be
                flushed if the oldest txn is committed. not the case here!
        x last changeset is invalid (right now the journal is re-applied
            from the beginning, but this would cause duplicate keys to be
            added twice) -> need to scan the file from the beginning and
            get the header of the last changeset (incl. lsn)
            x add a test (just truncate a few bytes)
            x also run manual tests as described in the original bug report
    x what if the recovery recreates pending transactions and then flushes
        them, and there's a problem during flush? these flushes are not covered
        by the journal and errors cannot be recovered from.
        x add a test
    x remove the journal trailer, it's no longer required
    x remove the journal header structure, it is not required (but always
        add a magic at the beginning of an entry)
    x do we really need to store the lsn in the page? - yes, it helps a bit
    x verify documentation in journal.h
    x make the threshold parameter configurable

x a test currently fails:
    --seed=1411263229 --use-cursors --duplicate=first --use-berkeleydb
../testfiles/2/ext_061.tst

x ZINT32: move code changes to a branch of hamsterdb-pro

x ZINT32: implement a NULL-compressor; it needs to keep track of
    the "compressed" size and whether a split is required
    x persist the number of compressed values, then use it to resize the
        ByteArray
    x check_integrity checks compressed size (+ overhead!) vs full_range_size
    x then run tests against berkeleydb

x refactoring: the btree "slot" should be plain integer instead of ham_u32_t

x ZINT32: add varbyte compression
    x make sure that the code runs "as is"
    x decode-function needs number of encoded keys (do not persist it in
        the compressor!)
    x but maybe the compressor needs to keep track of the used storage,
        esp. after decoding
    x move check_integrity into the compressor class (parameter is node_count,
        range_size)
        -> calculate the "real" size
    x the split is currently based on "simulated" results; if a split is
        required then a "real" compression should be performed to figure out
        how much space is left (if any)
        x requires a change in the interface
            (requires_split(size_t available_size))
    x fix the tests
    x right now files compressed with varbyte are as large as uncompressed
        files - but why? is it because the keyrange currently cannot shrink?
        -> yes; high initial capacity and no shrinking
    x check if some changes need to be ported back to the apl version

x refactoring: it would be nicer if the ham_paramter_t lists are passed to
    the Environment implementation and do not have to be parsed in hamsterdb.cc
    x rebase to v2
    x 2config/env_config.h: a struct with the run-time configuration of
        the environment
        x created in hamsterdb.cc/ham_env_create/ham_env_open and passed
            to all objects that are created
        x a State struct (no methods!) for
            - the ham_parameter_t list
            - the parameters from ham_env_open and ham_env_create
            (without any dependencies!)
            - log directory
            - remote address
            - remote timeout
            - encryption settings
            - page size
        x gets initialized with data from the header page
            x and with the parameters and the parameter list
        x can only be retrieved as const ref for the whole structure
    x 2config/db_config.h: a struct with the run-time configuration of
        the database
        x proceed as described above
            - db name
            - db flags

x when running ./ham_bench (without any parameters) then the debug version
    has a maximum insert latency > 1 sec (sometimes > 2 sec).
    -> caused by purging caches; whenever the cache is purged, at least
        20 pages (PageManager::kPurgeAtLeast) are purged
    -> a quick test without limit improved performance a lot, but there was
        one outlier with 1.2 seconds
    x run perftest without that limit
    x or try other limits (2, 5, 10) -> does not improve
    x at least fix the comment/variable name

x refactoring: once more check if we can unify the PaxLayout and
    the DefaultLayout (or move more code to the base class!)
    - no, not required. Stripping the library will reduce the size.

x refactoring: can we get rid of ham_record_t::_intflags and
    ham_record_t::_rid? at least deprecate them, then remove them with
    the next ABI change
    -> yes, just remove them. they are no longer used.

x refactoring: improve hola performance
    x improve performance for hola-sum (profile!)
        http://sites.utexas.edu/jdm4372/2010/11/09/optimizing-amd-opteron-memory-bandwidth-part-3-single-thread-read-only/
        s1 = a1 + b1
        s2 = a2 + b2
        s3 = a3 + b3
        s4 = a4 + b4
        return s1 + s2 + s3 + s4
    x run leveldb benchmark for comparison

x refactoring: rewrite capacity calculations (again...)
    x rename copy_to() to move_to() -- no!
    x get_full_record_size() and get_full_key_size() should return size_t,
        not double
    x do not persist capacity, only the range size
        x if a KeyList requires the capacity then it can store it internally
        x Instead of calculating an initial capacity, simply divide the
            ranges in the same ratio as the initial key/record sizes; i.e.
            if key size is 5, record size is 1, then the KeyList should be 5
            times larger than the RecordList.
        x exception is the PAX layout - no need to do any changes
        x remove KeyList::get_range_size() (or move the function to
            BaseKeyList, but don't persist it)
        x remove RecordList::get_range_size() (or move the function to
            BaseRecordList, but don't persist it)
    x for compressed lists it's not possible to efficiently shrink (reduce
        capacity) because it does not know it's final size. Right now there's
        a hack: Zint32KeyList returns a key size of 1 byte (instead of 4), and
        therefore mostly grows and rarely shrinks. But that's hackish.
        -> instead of calculating the required capacity rather ask for the
            minimum capacity for the current set of keys
        -> then add the K:R ratio as described above
    x require_split should return the number of bytes required; then adjust
        the K:R ratio
        x also make sure that at least 1 item fits into the adjusted space
        x increase the capacity of the UpfrontIndex only when required
            (currently it is always increased whenever a new range is assigned)
            x maybe pass a "capacity hint"? take it from the other list if
                it kHasSequentialKeys
            x if not then use a sane default value
                (additional space / item size, but at least 1)
            x what about shrinking? if capacity >> node_count then reduce
                the capacity
    x List:requires_split should no longer vacuumize
        x lists should rearrange themselves internally for the new key
            -> pass capacity + required data to vacuumize()
        x still no success? then call rearrange() in the caller
        x unittests are currently failing
        x test for filesize regressions against 2.1.8 w/ ham_bench
            x pax keys, pax records - ok
            x varlen keys, pax records - ok
            x pax keys, duplicates - ok
            x varlen keys, duplicates - ok
    x fix ./ham_bench --stop-ops=500000 --seed=1 --metrics=all --duplicate=last
        x it throws assertions in 2.1.8, and HEAD fails as well
        x add to monster test

    x re-enable journal.cpp:1296
    x fix performance regressions
        x things to check to improve performance
            x initial capacity could be taken from the node_count of previous
                pages (save when splitting)
            x rearrange requires sorting and many memmoves - very expensive
            x vacuumize should not adjust the capacity; this should be
                a separate operation. reason: vacuumize is called very
                often i.e. before splits/merges, and should not change the
                capacity then
            x reducing the capacity means that rearrange is not required,
                a memmove is enough
                current stats:
                    2.1.8   821.9m    31.7m BtreeIndex::insert
                    2.1.9   826.1mm   31.5m BtreeIndex::insert
    x move UpfrontIndex into its own file

    x the following tests fail
        x --seed=12345 --stop-ops=50000 --recsize-fixed=1
            x fix the crash
            x file size increased by 100%!!
        x --seed=12345 --stop-ops=50000 --recsize-fixed=0
            x fix the crash
            x file size increased by 100%!!
        x --seed=1380279291 --key=binary --keysize-fixed --duplicate=last --erase-pct=25 --find-pct=40
        x --seed=1380279291 --key=binary --keysize-fixed --duplicate=last
        x --seed=1380279291 --key=binary --keysize=128 --keysize-fixed --duplicate=last --erase-pct=25 --find-pct=40
        x --use-berkeleydb=true --reopen=true --use-cursors --duplicate=first ../testfiles/1/41.tst
    
    x currently, requires_split() is called twice for
        leaf nodes: in btree_insert.cc (were it should not be called), and in
        btree_node_proxy.h.
        However, if the call in btree_insert is removed, some tests fail, i.e.
            --use-berkeleydb=true --fullcheck=find ../testfiles/2/ext_050.tst

    x run monster tests
    x increase file format version
    x run performance tests

x see mail from Michael Moellney: cursor is not advancing properly when
    it's at the end of the database
    x reproduce w/ a sample
        The current unittest has a different behaviour; it fails when looking up
        keys with the cursor because the (approx.) key was not copied back
    x fix

o ZINT32: rebase hamsterdb-pro
    x refactoring: PodKeyList<ham_u32_t> has duplicate code with Zint32-list
        -> linear search 
    x then rebase hamsterdb-pro
    o start working on compressed data!
        x read the relevant sections of the DB2 paper once more
        x get rid of BtreeNodeProxy::prepare_flush()
        o get rid of the compressors; they're no longer required
        o the keys are split in blocks which are compressed; each block
            starts with the first uncompressed key (others are stored as delta)
            -> a block fits in a data cache line
            -> block is addressed by offset + size
        o index: 2 byte offset + 1 byte counter
        o default block size is 64
        o if block size == maximum size * 2 then split the block in the middle
            (unless the key is appended, then we can split immediately)
        o if block size == maximum size / 2 then try to merge with a sibling
        o first key in a block is uncompressed
        o insert in-place
            first try to insert in the current block if there is capacity
            if not then check if block size exceeds max * 2
                if yes then split and insert the new key while splitting
                otherwise make space and insert the key in the current block
        o blocks are searched with binary search
        o ... then use linear search/decompression for the block
        o erase in-place
            remove the key from the block
            if block is now empty: remove the block
            if block is only utilized by 50%: reduce space
            if left block + right block < 32: merge both blocks
        o need a custom search function (binary search for the block,
            linear search keys in a block)
        o vacuumize() could rearrange the blocks
        o scan() decompresses a whole block, then calls visitor
        o cache block offsets in a skiplist

    o copy relevant changes to base/apl

    o cache the last key & slot that was accessed; there should be a lot of
        operations accessing the same slot, maybe this speeds things up

    x review usage of compressed keys (zlib, snappy etc) - we should not cache
        decompressed values because after all we want to reduce RAM usage!
        -> ok, they're not cached

o refactoring: BtreeNodeImpl::print should use a stream object, like the
    KeyLists and RecordLists, and avoid the printfs

o refactoring: clean up/review BaseKeyList and its members
    x move check_integrity and vacuumize to Base
    o is erase_data really required? yes, but it looks like it's never
        called if a normal key is deleted; it's only called during cleanup
    o rename to erase_extkey, move to Base class
    o move get_simd_data() to Base class, return 0

o refactoring: rename erase_slot to erase

o refactoring: get_key_size() should return an integer instead of ham_u32_t

o device: use madvise(address, length, MADV_DONTNEED); when freeing mmapped
    pages. There is no equivalent on Win32.
    o but run performance tests!

o PRO: review AES usage in read_page; if the page is mmapped
    then decryption is not applied

o when the file format is changed then...
    x internal node layout: store page IDs div pagesize to get smaller
        integers (will be compressed better)
    o improve node layout compression (when the file format changes)
        x flags are not required at all if fixed length record size > 8
            (and record size is too large for inline records)
            -> set m_flags to null if they don't exist -> avoids a new member
        x UpfrontIndex: use bit packing to compress slot/offset pairs?
            -> no, would be difficult to gain something; big efforts
        o compress the flags for the DefaultRecordList (4 bit per item)
            -> are 4 bit sufficient if compression is enabled? - yes!
            o update get_required_range_size()
            o erase_slot() needs to use a loop
            o insert_slot() needs to use a loop
            o update all other usages of m_flags
    o add to monster testsuite
    o rebase hamsterdb-pro

x refactoring: use "int duplicate_index" instead of ham_u32_t

x refactoring: use "int" for record counters

o erlang fixes are required
    o 2 tests are failing
    o quickcheck-ci.com
    o look into Thomas' mail
    o QuickCheck: create a new property for testing duplicates; the key is
        always the same. The number of duplicate keys is tracked and
        periodically checked with the API. A cursor can be used to remove a
        specific duplicate, or to fetch a specific duplicate.
    o QuickCheck: create a new property for testing recnos, with lots of deletes

o windows cleanups
    o The C# PInvoke for ham_cursor_find is missing the Record structure
        - also accept flags in ham_db_find and ham_cursor_find for approx.
            matching, and copy the key!
    o install VS2008 on the new harddisk
    o install VS2010 on the new harddisk
    o build release lib/dll with /PDBSTRIPPED (reduces file size?),
        or figure out why the file size is so big
    o need win32 python project (or wait till someone needs it?)
    o a few projects are not built (hamzilla_debug_x64, server_dll_x64...)
        or end up in wrong directories
    o C# unittests sporadically fail b/c a handle is closed multiple times
    o automate the build process
    o ... and the packaging

o "make dist" should write the current git commit and the build date to
    a file; this should be printed by ham_bench and the tools
    o ham_bench: print this prior to the monster tests/performance tests
    o get rid of HAM_API_REVISION, move HAM_VERSION_* to the header file, or
            move version.h to include/ham

. delta updates managed in the BtreeNode
    the operations are attached to the node, but as soon as the node
    is accessed for a lookup or a scan, or immediately before the node
    is flushed, the deltas are merged into the node. So far this does not
    sound too efficient, but the bulk updates in combination with the
    key compression (i.e. for prefix compression) will benefit a lot.

    Also, they are really required for concurrency and to allow multiple
    writers in parallel.

    x perform a benchmark/profiling: random inserts vs. ascending inserts;
        the difference should be caused by memcopy/memmove (is it?)
        x PAX
            -> absolutely worth the effort, about 60% are spent in memmove
        x Default
            -> also worth the effort, about 15% are spent in memmove

    o need a flag to disable DeltaUpdates
        o add flag to ham_bench
    o rename TransactionOperation to DeltaUpdate, decouple code from txn
    o totally transparent to the caller, handled in the proxy
    o only add deltas to leaf nodes; internal nodes have too many read
        operations and would anyway require immediate flushes
    o DeltaUpdate objects from a txn-flush should directly go down to
        the node (detach from txn, attach to node)
    o should the the insert + set_record operations be combined into a
        single call? this has the additional advantage that the overhead
        of calling set_record will disappear
    o merge delta updates when reading and flushing
        o however, for simple lookup calls (no duplicates) the DUs can
            be traversed, too 
    o requires_split() must take delta updates into account
    o make the merge algorithm as efficient as possible
        o sort deltas by key
        o first execute all 'erase' either against other deltas or against
            the node
        o then merge the remaining inserts
        o this needs lots of tests
    o now run tests: should every update be stored as a DeltaUpdate? If not
        then disable them by default, unless Transactions are used (and unless
        bulk updates are used)

. refactoring: make device stateless and avoid inheritance
    - virtual abstract base class
    - implementation class uses template parameters
    - template parameters have logic; implementation class has state
    - state is passed to the logic and can be modified (exception safe)
    - get rid of dependency to env, only to EnvironmentConfiguration

    - if this works then do the same for BlobManager
    - if this works then do the same for PageManager
    - if this works then do the same for EnvironmentHeader
    - if this works then do the same for Journal
    - if this works then do the same for Page
    - if this works then do the same for Compressor
    - if this works then do the same for Changeset
    - if this works then do the same for Btree

. refactoring: get rid of inheritance for env
    - move implementation to a struct, w/o state
    - struct will be kept separately (if there is any)
    - base class will be abstract
    - the env will become a "hub" which manages members (i.e. page_manager,
        device) and forwards the calls to those members 
    - implementation class uses a template parameter and forwards calls
        to the struct; the state is a parameter which is only updated
        if the operation succeeds
    - if this pattern works then also apply it for Database,
        Transaction, Cursor

. refactoring: improve the code separation of cursor and txn_cursor, i.e.
    in db_local::cursor_get_record_size (wtf - is_null(0)?)
    etc
    -> clean up the whole Cursor stuff

. refactoring: clean up the whole Database code; it's too much and too
    complex

. documentation rewrite
    o use github wiki
        o remove old cruft

    /introduction
    /evaluate & benchmark
    /faq (merge w/ performance)
    /tutorial
    /pro
    /c, c++
        overview (description, status)
        installation
        usage (compiling, linking)
        api functions (one file per function)
        samples
    /java
        overview (description, status)
        installation
        usage (compiling, linking)
        api functions (one file per function)
        samples
    /dotnet
        overview (description, status)
        installation
        usage (compiling, linking)
        api functions (one file per function)
        samples
    /erlang
        overview (description, status)
        installation
        usage (compiling, linking)
        api functions (one file per function)
        samples
    /python
        overview (description, status)
        installation
        usage (compiling, linking)
        api functions (one file per function)
        samples
    o look for a technical writer to review the files

. use cache-oblivious b-tree layout
    ===> a much simpler approach would be to reserve "X" bytes when creating
        the environment (and then map the whole range)
        this would include storage for the blobs AND we would not have to mess
        around with the mapping
    -> http://supertech.csail.mit.edu/cacheObliviousBTree.html
    o see roadmap document for more information
    o this feature is *per database*
    o calculate number of reqd pages based on estimated keys from the user
        (but what about the blobs??)
    o make sure that this is not reverted when "reduce file size" feature
        (above) is enabled
    o the new pages are not managed by the freelist! therefore the freelist
        will not need any modifications
    o after resize: mmap the whole file area. this is actually important because
        mmap is much faster than r/w; but when the database is created, the
        original mapping already exists. therefore we might have to handle
        more than one mapping in the file
    o PageManager: when allocating a new page then use the distribution
        function to fetch a page from the reserved storage
    . try to batch allocations; when new pages are required then don't just
        allocate one but multiple pages (if the database is big enough)
        -> could create a second memory mapping for the next chunk

. release-v2.pl: valgrind takes sooo long. should we use clang's
    AddressSanitizer instead? or both?

. hola - next steps
    o support java api
    o support .net api
    o support erlang api
    o lua-functions as callbacks - then remote marshalling will work
    o PRO: compile callbacks with clang remotely
    o add remote support where it makes sense (only for PRO?)

. architecture for a new webpage
    o pick an awesome design
        i.e. similar to http://foundationdb.com, http://laravel.com,
        http://rethinkdb.com, http://www.orientechnologies.com
    o use make/m4/markdown to generate static pages:
        https://github.com/datagrok/m4-bakery
        https://developer.github.com/v3/markdown/
    o come up with the full site structure/contents
        http://sidekiq.org/pro/
        o include full documentation, one page per API
        o ... and for all languages
        o keep the documentation in the source tree, not in -www?
    o documentation comments are hosted on disqus
    o blog comments are hosted on disqus, articles are also written in markup

    o static pages will be served with nginx, using url rewrites
    o dynamic pages are created with a micro-framework (silex?)
    o Makefile can "scp -r" everything to the servers (staging or production)

    . client area with (low priority)
        o authentication
        o collection of files
        o analytics (who downloads what and when?)
    . admin area with (even lower priority)
        o authentication
        o customer database
        o implementing business processes
        o sending out release emails
        o importing new releases
        o etc

. look into spark, mongodb and mariadb integration
    -> like MapReduce, Spark requires an InputFormat class; templates are 
        available here:
        https://github.com/hypertable/hypertable/blob/master/src/java/MapReduce/org/hypertable/hadoop/mapreduce/InputFormat.java
        https://github.com/hypertable/hypertable/blob/master/src/java/MapReduce/org/hypertable/hadoop/mapred/TextTableInputFormat.java (streaming)

    -> would be an interesting market with requirements for column store
        storage
    -> how does the integration look like?
    -> has TPC-benchmarks and other benchmarks ready
    o write down everything i find, collect information and estimate
        efforts/gains (will do the same for mysql, R and mongodb later); this
        task is not about writing code!

------------- hamsterdb pro 2.1.9 ------------------------------------

o PRO: rebase to vanilla 2.1.9

o PRO: find an efficient compression method for RecordLists, more precisely for
    - default record lists (incl. flags, record IDs)
    - internal record lists (page IDs)
    - duplicate record lists (incl. flags, record IDs)
    The compression method should allow fast binary search.
    The page IDs should be modulo page-size (makes numbers smaller)

    o GroupedVarints should be parameterized and work for 32bit and 64bit
        numbers and a variety of capacities
    https://github.com/stuhood/gvi/blob/master/src/main/java/net/hoodidge/gvi/GroupVarInt.java
    http://www.oschina.net/code/snippet_12_5083
    http://www.ir.uwaterloo.ca/book/addenda-06-index-compression.html
    -> the concept will be similar to prefix compression
    -> can we come up with a schema that allows compression AND
        fast random access?

o PRO: prefix compression for variable-length keys
    use an indirection for the prefixes and suffixes; store each
    part in a slot. the keys themselves have then fixed length (2 slot id's)
        ==> supports efficient binary search!
        ==> is efficient for random read/writes AND linear scans
        however, it's very complex to figure out how to optimally split the
        strings into prefixes and suffixes
    ==> prefixes and suffixes can be stored as extended keys if they become
        too large
    see indexcompression2009.pdf - Efficient index compression in DB2 LUW

    o if key is appended at the end: just write the delta
    o every "n'th" (50th?) key is written uncompressed
    o otherwise append a delta-update to the page, and "merge" all deltas
        before the page is flushed. This will improve performance for batched
        updates, since they will cause only one page compression for
        multiple updates.
    o however, it's tricky to figure out whether a node requires a split or
        not, since it requires a good estimate of the size for the new key 
        -> if in doubt then just perform the merge
    
    o full keys can be further compressed with lzf or lzo
    o key search: jumps from full key to full key; in between, there's a
        linear search for the key

o PRO: compress the varkey index (slot size/offset)?
    ==> come up with a good scheme
    -> for APL

o PRO: bulk updates
    - require delta updates
    - give users API to allocate memory for keys/records
    - if user says that data is already sorted then do not re-sort, but
        fail hard if the sort order is violated
    - add those delta updates to the txn-trees or to the btree node,
        simply transfer ownership of the memory
    -> or are these "batched" updates, in combination with cache-oblivious
        btrees? the batched updates contain lists of structures with
        information about the update (i.e. insert, erase etc). internally,
        a cursor is used to perform the update. this would be fast and a
        relatively cheap way to perform multiple operations in one
        single transaction. and they would not require delta updates, but
        still provide real value.
    o also for remote, transfer in a single message
    o also for .NET
    o also for java
    o also for erlang
    o also for python

------------- hamsterdb 2.1.9 ---------------------------------------

. hola: use sum-prefix-trees to precalculate partial sums/results?
    they could be stored in a btree, and used to dynamically recalculate
    requested values 
    https://www.cs.cmu.edu/~guyb/papers/Ble93.pdf

o QuickCheck: automatically test the recovery feature by invoking "crashes"

o the bucket for concurrency TODOs
    this are the requirements:
    - PRO: inserts are fully concurrent (APL: only one insert at a time)
    - transactions are flushed in background
    - dirty pages are flushed in background
    - reading pages is synchronous, writing pages is asynchronous
        -> needs a very fast locking scheme
    - SSDs support many async. writes in parallel - be prepared!
    http://meetingcpp.com/tl_files/2013/talks/scaling_with_cpp11_edouard_alligand.pdf
    - remove db_get_last_error?
    - how to deal with temporary pointers (key->data, record->data)?
        store them in tls? or always allocate new pointers and let the caller
        delete them?

    o an intermediate stage would be to have concurrent reads but exclusive
        writes (one writer, many readers) - makes sense?

    o create coding rules
        o synchronization either in lowest or highest level of the callstack
        o when to use what kind of synchronization
        o which modules are single-threaded/synchronized, which are atomic,
            which are concurrent?

    o how can we verify the correctness of the implementation?
        - i.e. by using static analysis or dynamic analysis, together
            with annotated code/custom tools? even if these tools do not
            exist then a system of annotations/naming conventions can help
            writing/maintaining the code

    o mutex implementations should have built-in monitoring, i.e.
        number of locks/unlocks, wait times, contention etc
        o need read/write mutex, fast latches

    o come up with a list of all functions, define which locking operation
        is required; then review the code and make sure this will work
        o the environment configuration
        o the database configuration
        o the transaction tree handling
        o the page manager, the device and the cache
        o the btree
        o the btree nodes (i.e. extkeycache, compressor)
        o parallel lookups (using the same memory arena)

    o reduce the linked lists - they're hard to be updated with atomic
        operations
        o page
        o transaction and dependent objects
        o ...

    o separate SMOs from the actual operation (#2)
        -> check the literature
        http://pdf.aminer.org/000/409/763/b_trees_with_relaxed_balance.pdf
        o move SMO operations to "the janitor" (btree_janitor.h)

    o the global environment-lock should go because it's expensive; rather
        increment an atomic latch, and refuse to close/erase the database as
        long as the latch is > 0 




o PRO: hot backups (vacuumizes to a different file)
    really only for PRO?
    http://sqlite.org/c3ref/backup_finish.html
    - make sure that all transactions are closed
    - perform ham_env_flush
    - then copy the file
    - if compaction is enabled: copies keys w/ iterator
        (later: performs bulk updates)
    --> think this through; how to deal with delta updates? -> merge them
        what if only a few databases should be backed up?
        what if i want to back up in a logical format (i.e. csv)?

o "hola" - olap functions that operate directly on the btree data
    -> see wiki
    -> see java8 stream API:
        http://download.java.net/jdk8/docs/api/java/util/stream/Stream.html
    -> see supersonic:
        https://code.google.com/p/supersonic/
    -> see fast bitmap indices
        http://code.google.com/p/lemurbitmapindex/
    o create a design
    o operations on compressed data (COUNT(), MIN(), MAX(), ...)?
    o use async operations or futures/promises
    o deprecate ham_db_get_key_count() (tutorial, documentation)

- bloom filter -> PRO
- concurrency -> PRO

. clean up approx. matching
    o ONLY for cursors
    o Flags: HAM_FIND_LT_MATCH | HAM_FIND_GT_MATCH | HAM_FIND_EQ_MATCH (default)
    o lookup: the cursor is coupled to the key, even if the lookup fails
        then perform a lookup:
            found_key == requested_key:
                HAM_FIND_EQ_MATCH: ok
                HAM_FIND_LT_MATCH: return move_prev()
                HAM_FIND_GT_MATCH: return move_next()
            found_key < requested_key:
                HAM_FIND_LT_MATCH: ok
                HAM_FIND_GT_MATCH: return move_next()
                HAM_FIND_EQ_MATCH: key not found
            found_key > requested_key:
                HAM_FIND_GT_MATCH: ok
                HAM_FIND_LT_MATCH: return move_prev()
                HAM_FIND_EQ_MATCH: key not found
    o must work with transactions
    o do not store key flags; the caller has to compare the key
    o remove ham_key_set_intflags, ham_key_get_intflags, key->_flags (?)

. win32: need a release-v2.pl which fully automates the various release steps
    o delete all generated protobuf files
    o build for msvc 2008
    o run unittests for debug and release
    o run samples
    o delete all generated protobuf files
    o build for msvc 2010
    o run unittests for debug and release
    o run samples
    o build release package

. also remove locking from C# and Java APIs

------------------- idea soup ---------------------------------------------

. PRO: should we have a separate "recsize == 0" RecordList for duplicates?
    they could only store the duplicate count (but should be able to deal
    with duplicates that are > 256!)
    -> requires grouped varints

o asynchronous prefetching of pages
    -> see posix_fadvice, libprefetch

o when recovering, give users the choice if active transactions should be
    aborted (default behavior) or re-created
    o needs a function to enumerate them

o A new transactional mode: read-only transactions can run "in the past" - only
    on committed transactions. therefore they avoid conflicts and will always
    succeed.

o need a function to get the txn of a conflict (same as in v2)
    ham_status_t ham_txn_get_conflicting_txn(ham_txn_t *txn, ham_txn_t **other);
        oder: txn-id zurückgeben? sonst gibt's ne race condition wenn ein anderer
        thread "other" committed/aborted
    o also add to c++ API
    o add documentation (header file)
    o add documentation (wiki)

. new test case for cursors
    insert (1, a)
    insert (1, b) (duplicate of 1)
    move (last) (-> 1, b)
    insert (1, c)
    move (last) (-> 1, c)? is the dupecache updated correctly?

. there are a couple of areas where a btree cursor is uncoupled, just to
    retrieve the key and to couple the txn-key. that's not efficient
        db.c:__btree_cursor_points_to
        db.c:__compare_cursors
        txn_cursor.c:cursor_sync
        txn_cursor.c:cursor_overwrite
    o move to a separate function
    o try to optimize

. add tests to verify that the cursor is not modified if an operation fails!
    (in cursor.cpp:LongTxnCursorTest are some wrapper functions to move or
    insert the cursor; that's a good starting point)

