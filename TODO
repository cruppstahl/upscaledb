I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

-----------------------------------------------------------------------------
This Branch Is About Integrating The hamsterdb2 Functionality!!!!!
-----------------------------------------------------------------------------
The big headline is:
As a user i want to run many Transactions in parallel with high performance.
I'm using multiple threads b/c my CPU has multiple cores, and expect hamsterdb
to scale with the number of cores.
==============================================================================

high-level plan for 2.1.4 ..................................................
x check for scalability issues with files > 1 GB
x improvements for ham_bench
x get rid of the freelist
x improve scalability
- erlang wrapper
-----------------------------------------------------------------------------

x update copyright string: 2013 -> 2014

x check for scalability issues with files > 1 GB and check if we're on the
    right track regarding scalability
    -> remove the freelist
    -> add delta updates to avoid memmove in the index pages

x ham_bench: new test mode: first load with LOTS of data, then erase in the
    same order (or in random order or reverse order) till the database is empty
    - implementation idea: when switching to ERASE, perform a reset() on the
        NumberGenerator, and it will start delivering the same sequence as
        from the beginning
    x add a reset() method to the datasources
    x new command line options --bulk-erase
        x if set then reset() datasource, delete
        x NOT for parser-generator (print error)
        x only for stop-ops
    x add to monster tests

x get rid of the freelist for pages (not yet for blobs)
    The PageManager keeps a (persistent) list of all pages, including their
    id, their size, the type, the database. It keeps a separate list with
    all free pages.
    x the PageManager has a list of all pages. this effectively replaces
        the cache
    x the PageManager knows if a page is old or not, and whether it can
        be flushed to disk
    x get rid of the "totallist" linked list of all pages
    x get rid of the "bucket" linked list of all pages
    x remove HAM_CACHE_FULL and HAM_CACHE_STRICT - don't think it is used
    x the PageManager knows whether a page is free or not
        x no longer use the freelist to manage empty pages, only for blobs
    x when allocating new pages: check the internal list, not the freelist
    x store the modified list on disk, load it
        x implement store/load methods
        x store blob-id in the environment header 
        x load when env is opened
        x store when env is closed
        x PageManager must accept entries which are available but do not
            have a Page pointer
        x fix unittests
    x pax-layout with recsize == 0: must be much faster now
        -> yes, but purge_cache requires 30% of the time now
        x re-introduce totallist
    x move the unittests from cache.cpp to page_manager.cpp, update them
    x do not persist state if Environment is in-memory 
    x re-activate unittests in log.cpp
    x if logging is enabled: immediately write the modified state
        (later this will be rewritten as incremental updates for the log)
        x verify recovery tests

x support pages with different sizes
    x for now just keep the setting as is (HAM_PARAM_PAGE_SIZE in the Env)
        x but the page stores its size persistently (for debugging)
        x always use page->get_page_size(), if possible
        x when loading a page: assert that page_size is correct
            (if a header exists)

    x make sure that the log can work with different sizes

    x device: make independent of page size
    x Page::allocate must accept page size as parameter

    x if a free page is deleted then delete the Page pointer, but keep the
        entry in the map, otherwise we lose the information whether the page
        is free
    x PageManager must store page sizes (and persist them)
    x when allocating a page: check freelist for pages with this size
    x PageManager->is_cache_full() must take the sizes in account

x v2: fix compilation problems on MacOS

x remove the freelist
    x blob: remove direct I/O - it's barely used anyway
    x completely get rid of the freelist
    x blobs no longer need to be aligned

    x very large blob pages no longer span multiple blobs but create a
        single page which is large enough
        x PageManager::alloc_page needs page-size parameter
        x PageManager::fetch_page does not require parameter cache_only
        x PageManager::fetch_page needs to know the size
    x blobs no longer cross page boundaries
    x this allows lots of cleanups in DiskBlobManager::read_chunk/write_chunk,
        because there's always just ONE page, not more
        x still uses env->get_page_size()
    x every page now has a page header, even blob pages
    x every blob page now has a blob page header with a counter ("free bytes")
        and a small freelist (constant length)

    x update the "free bytes" counter after overwriting, allocating and erasing
        blobs to/in/from this page
    x keep the actual freelist VERY simple - i.e. do not merge empty
        blobs, i.e. only store the 32 largest free entries etc

    x PageManager state persists page sizes for all pages with non-default size
    x The PageManager caches the id of the last used blob page to
        check for free space
    x verify that m_needs_flush is always updated correctly

    x re-activate unittests
        x implement PageManager persistence (simply reserve a page)
            x needs unittest
    x implement/update reclaim_space()
    x update freelist counters for metrics
    x also check recovery tests

    x git rm src/freelist* unittests/freelist*

    x improve performance
        x all pages have fixed size (except blob pages)
            x remove page->get_size()
            x adjust page->allocate, page->fetch
        x remove PageManager::get_page_from_address()
        x blob pages spanning multiple pages do NOT have a header!
        x the page-map ONLY persists free pages

    x run performance tests (compare PAX against 2.1.3, release build)
        - with records, 1 mio
            --seed=1389874598 --key=uint64
                                2.1.4           head
            total time:         9.272876        7.827158
            file size:          1159331840      1118830592
        - with records, 5 mio
            --seed=1389874598 --key=uint64 --stop-ops=5000000
                                2.1.4           head
            total time:         64.212313       51.958598
            file size:          5832523776      5595086848
        - with records, 1 mio, 30% erase
            --seed=1389874598 --key=uint64 --erase-pct=30
                                2.1.4           head
            total time:         6.530221        5.632957
            file size:          807469056       781975552
        - with records, 5 mio, 30% erase
            --seed=1389874598 --key=uint64 --stop-ops=5000000 --erase-pct=30
                                2.1.4           head
            total time:         44.115751       36.708448
            file size:          4074618880      3898146816
        - without records, 1 mio
            --seed=1389874598 --key=uint64 --recsize-fixed=0
                                2.1.4           head
            total time:         3.155387        3.164027
            file size:          10534912        10534912
        - without records, 5 mio
            --seed=1389874598 --key=uint64 --recsize-fixed=0 --stop-ops=5000000
                                2.1.4           head
            total time:         27.179945       27.616605
            file size:          67125248        67125248
        - without records, 1 mio, 30% erase
            --seed=1389874598 --key=uint64 --recsize-fixed=0 --erase-pct=30
                                2.1.4           head
            total time:         2.255874        2.238849
            file size:          8421376         8421376
        - without records, 5 mio, 30% erase
            --seed=1389874598 --key=uint64 --recsize-fixed=0 --erase-pct=30 --stop-ops=5000000
                                2.1.4           head
            total time:         20.919253       20.989679
            file size:          33898496        33816576

x v2: Fix .NET Wrapper issue: VS2010, SampleDb1. See
    https://github.com/cruppstahl/hamsterdb/issues/29 for details

x improve the freelist
    The current implementation is limited because it only supports one page
    to persist the PageManager's state. More than one page has to be
    supported, and logging must be efficiently (i.e. only log those pages
    that are modified.)
    x only freelist operations are logged
    x Reenable Env/eraseMultipleDatabases
    x Reenable Env/eraseMultipleDatabasesReopenEnv
    x store freelist on multiple pages, if required
        x implemented, but needs a test
    x BlobManager: merge adjacent free blobs
    x if a blob page is completely empty: add it to the freelist
        x add test
    x if page is a multi-page: add all pages separately

    x when closing: perform reclaim_space() BEFORE flush_all_pages(),
        and flush_all_pages() should NOT flush the state_page;
        instead (afterwards), the state is flushed and the state_page
        is flushed. afterwards, no more pages are allowed to be modified.
        -> that's already the case...
    x check recovery tests

x improve PageManager performance
    x if logging is enabled and a freelist entry is *added* then this change
        must not be logged. However, if a page is *taken* from the freelist
        then it must be logged.
    x use the non-intrusive hash table from 2.1.3
        x manage free pages in separate freelist (std::map)
        x cached pages are stored in a non-intrusive hash table
    x improve multi-page handling
        x PM::alloc_multiple_blob_pages() needs to be implemented
            x add tests
    x check performance again
    x compress the freelist state
        x collapse single free pages to multi-page blobs
        x 1 byte header
          - 4 bits: number of following bytes for page-id
              (address % page_size)
          - 4 bits: the multi-page counter
        x n bytes: page-id, multiple of page-size
        x add test for encode/decode
        x add test for collapsing
    x run recovery tests

x shouldn't we use PAX if key==uint64 and record size is variable?  -> it does!

x perftest
    x add tests with more elements (i.e. 10 mio ops)
    x ... and with very big records (1mb)

x perftest: add bulk erase for all 3 distributions (no records required,
    500k are enough)

x v2: verify/improve performance of btree_impl_default: it has a very high
    number of page splits compared to 2.1.3, even if the key size is <= 21.
    Why? maybe the capacity is not calculated correctly. or do keys have
    more overhead than in 2.1.3?
                                2.1.3           head
        - variable length keys (no duplicates)
            --recsize=0 --seed=1389874598 
            splits:             2043            1993
        - variable length keys (no duplicates)
            --recsize=0 --seed=1389874598 --keysize=64
            splits:             6649            4141
        - variable length keys (with duplicates)
            --recsize=0 --seed=1389874598 --duplicate=last
            splits:             2043            2067
        - fixed length keys (with duplicates)
            --recsize=0 --seed=1389874598 --key=uint64 --duplicate=last
            splits:             1958            2002

o run monster tests
    x add test: bulk-erase, page_size 1024, key_size 64, extkey-threshold 30
    x BtreeDefault/eraseReverseExtendedKeySplitTest
    x BtreeDefault/eraseReverseKeySplitTest
    o ./ham_bench --use-berkeleydb=true --key=binary --keysize=64 --pagesize=1024 --recsize=0 --bulk-erase --extkey-threshold=20 --stop-ops=1000000

o web-page requires updates
    x deployed html differs from git-repository
    o www1
        o merge git repository of www1 (host on github, keep remote branch)
        o clean up 'dl' directory
        o where to host static files?
        o backup and deploy to www2, use round-robin DNS

high-level plan for 2.1.6 ...................................................

o erlang API
    o with quickcheck coverage for...
        o database operations (create/close/open/erase/rename)
        o database operations with insert/erase/find
        o database operations with many insert/erase/find/table_scans
        o ... add transactions
        o ... add many cursors

o improved logging/journalling
    - merge both files (log + journal) into one
    - log is now buffered (could even be compressed, encrypted)
    - PageManager state now writes to journal

o delta updates (DU)
    - insert SMOs (splits) are applied when "going down"
    - erase SMOs are vastly simplified (only merges, no shifts)
        - never delete slot 0 of a page, only mark as deleted
        -> check the literature
    - SMOs are separated from the actual operation
    - the actual operation now becomes atomic and simply attachs a DU to
        the modified page
    - creating a DU requires a single memory allocation!
    - DUs are stored in the journal as a logical operation
    - DUs are merged synchronously as soon as there are too many or the
        page is flushed or a lookup is performed
    - find a single solution for transactions AND regular updates
        is this possible? they both serve different purposes, and the
        consolidation could become very tricky (think of cursors, 
        approx. matching...)
        - but maybe the txn opnode/op could *point* to the DU?
        -> or: store DeltaUpdates in the TransactionIndex? then we could reuse
            the consolidation logic

o improve integration of static code analysis in release process
    o oclint
    o coverity

high-level plan for 2.1.7 ...................................................

- page flushes/cache purges/flushing txns is handled asynchronously in the
    background
    TODO TODO TODO

- reduce the linked lists - they're hard to be updated with concurrent
    operations
    o page
    o transaction and dependent objects
    o ...

o support efficient logging
    o a log IS-A journal: it has "streams" with separate "entries", each has
        a lsn, a header and a payload; both buffer (and compress/encrypt), flush
        -> try to merge both; the log is first processed (starting from the
        end of the file), then the journal (starting from the beginning and
        skipping all log entries)
        -> store the lsn of the last modification in the page (right now
        it's stored in the log header, i think)
    o journal (and log) could buffer the pages and only write them to disk
        when the buffer overflows or a transaction is committed
        (later: this buffer could be compressed -> PRO)
    o the log remains responsible for the btree, the journal is a logical
        backup for the delta updates/txn updates
    o instead of flushing the full state, the PageManager could write "deltas"
        to the log
    o ... and the delta updates would be identical to the txn-operations
    o play around with certain thresholds; don't switch the file too often
    o when merging delta-updates, the log should try to store all delta-updates
        into one Changeset, and therefore flush the log only once (with
        combined updates)

    - the btree/data file is INDEPENDENT from the log! it has only atomic
        updates and might become out-of-sync with the actual log. This is by
        design and must not cause problems! this will later allow us to run
        "compactions" in background.
    - the log contains logical "streams", i.e. for PageManager, for each Page
        etc
    - the log writes checkpoints of those streams if the number of delta
        updates exceeds a threshold
    - the log buffers the data and only flushes/fsyncs when requested
        (TODO this needs to be clearly defined!)
    - whenever a Btree page is flushed, the log will contain a "flush" marker
        of this page (and the lsn of the last update which modified this page).
        this marker is stored in the log's PageManager stream
        (can this marker be stored in the page itself?)
    ? what about SMOs?
        they're performed atomically in the Btree by updating/allocating all
        pages, modifying them, updating the PageManager stream in the log
        and then switching atomically in the PageManager map
    ? a insert with a duplicate table or extended key is not atomic; how
        can we solve this?
    ? how is recovery performed?
        - read the last buffer from the last logfile (the tail contains a
            header)
        - uncompress, if it was compressed
        - ...?
    ? can this asynchronousness cause problems?
    ? when/how to fsync?

  - StreamContainer
    - a collection of static buffers (i.e. pages, header page) and streams;
      all stored in one file. each stream contains segments with a small
      header (stream-id, subject, lsn, number of buffers), one or more
      buffers (size, checksum?) and a trailer (last checkpoint of metadata,
      last checkpoint of page-manager)
    - buffers data before writing to file, but flushes (and fsyncs) on
        demand
    - implementation for in-memory remains empty
    - requests checkpoints from streams if there are too many delta updates
    - uses log-file switching: if one file overflows then switch to a second
        file, write checkpoints and continue
    - can maintain its own Stream where it stores its own state: the buffers
        that were written to disk, which streams are in these buffers,
        are they obsolete through newer checkpoints etc
    - use this information to garbage-collect buffers and re-use them
    - add to LocalEnvironment
    - vacuum: ask all streams to perform checkpoints, and flush the buffer
        into a separate file; then rename the file 
    - move the Environment's configuration to a separate object
    - move the Database's configuration to a separate object

  - StreamContainer ("sc") #2
    - perform full transition by moving the remaining modules to the sc
    - pages: fetch/flush from sc file
    - journal: write to sc stream
    - log: write to sc stream
    - remove the device classes


- prefetch
- linear SIMD search -> PRO
- compress the whole LSS (and the log) with snappy -> PRO
- encrypt the whole LSS (and the log) with AES -> PRO
- hot backups (vacuumizes to a different file) -> PRO
- compression -> PRO
- bulk updates -> PRO
    - give users API to allocate memory for keys/records
    - if user says that data is already sorted then do not re-sort
    - add those delta updates to the txn-trees or to the stream
- first PRO release
    o webpage updates, PR, mailings
- cache-oblivious page distribution? (maybe write the LSS first?)
    http://supertech.csail.mit.edu/cacheObliviousBTree.html
- bloom filter -> PRO
- concurrency
- operations on compressed data (COUNT(), MIN(), MAX(), ...)?
- C-Store style projections? (requires complex schema types)
    - introduce a new library with complex schema types, projections
    - analytic functions
        count, min, max, sum, product, average, ln, sqrt, exp, round, trunc,
        date/time functions and interval functions
    - select(predicate_t, column_descriptor_t, select_state_t)
             \- an AST of functors
                          \- existing columns or generated columns (i.e. sum())
                                                \- keeps track of offset, count
    - erase(predicate_t)
    - explain(predicate_t, column_descriptor_t)

o introduce PRO version
    o start a closed repository
    o one source base with different licensing headers, different licensing
        string (also for tools), different version tag
    o API to get licensee information (is_pro_version())
    o new release process
    o prebuilt win32 files
    o get rid of serial.h - it's not really required and only creates efforts
    o how to share files with customers? need a login area,
        downloadable, customized files (win32, serial.h, tarballs...)
        -> send out mails if a new file is available
    o evaluation license: build binaries for the most common architectures
        o insert expiration date checks
        o special copyright strings
        o prebuilt for win32/win64
        o unix: obfuscated source code
        o need an automated flow for signups, for evaluation licenses etc
    o extra documentation
    o define file format interoperability?
    o what are the minimum features required for the first release?
        - (evaluation licenses)
        - prefix compression for strings
        - lightweight compression for binary keys
        - SIMD for searches
        - AES encryption
        - hot backups

o PRO: btree can compress keys
    x get rid of the whole minkey/maxkey handling because these numbers
        are irrelevant with compression
    o try to reduce the changes to a new KeyProxy object
    o prefix-compression for strings
        o each 2kb have a full string (indexed by skiplist)
    o delta-compression for numeric data types (>= 32bit)
        (can this be combined with a bitmap compression? the deltas are
        compressed in a bit-stream? but then we end up with variable
        length encodings...)
    o lightweight compression for keys
        http://oldhome.schmorp.de/marc/liblzf.html
        http://lzop.org
    o record compression for blobs (lzop.org? snappy?)
        better postpone this and compress all pages in the lss
    o do we need delta updates for efficient inserts? - i think not yet...

o PRO: use SIMD for fixed-length scans and __builtin_prefetch
    o use valgrind to track cache misses
    http://pcl.intel-research.net/publications/palm.pdf
    http://www.cs.toronto.edu/~ryanjohn/teaching/csc2531-f11/slides/Ioan-SIMD-DBMS.pdf
    http://gcc.gnu.org/onlinedocs/gcc-3.3.6/gcc/Other-Builtins.html
    http://stackoverflow.com/questions/8460563/builtin-prefetch-how-much-does-it-read
    http://tomoyo.sourceforge.jp/cgi-bin/lxr/source/include/linux/prefetch.h
    http://stackoverflow.com/questions/7327994/prefetching-examples
    o use linear search with fixed length keys (if max-keys-per-page
        or the subrange in the binary search is low enough, and if the
        performance makes sense) -> also for MIT
    o if both layouts use binary search then move it back to the proxy!

o release-v2.pl: add test without berkeleydb

o use cache-oblivious b-tree layout
    o see roadmap document for more information
    o run a performance test/prototype if this is worth the effort
        o allocate a fixed number of pages (20) for the index
        o PageManager: when allocating a new page then use the distribution
            function to fetch a page from the reserved storage
    o this feature is *per database*
    o calculate number of reqd pages based on estimated keys from the user
    o make sure that this is not reverted when "reduce file size" feature
        (above) is enabled
    o the new pages are not managed by the freelist! therefore the freelist
        will not need any modifications
    . try to batch allocations; when new pages are required then don't just
        allocate one but multiple pages (if the database is big enough)

. clean up approx. matching
    o ONLY for cursors
    o Flags: HAM_FIND_LT_MATCH | HAM_FIND_GT_MATCH | HAM_FIND_EQ_MATCH (default)
    o lookup: the cursor is coupled to the key, even if the lookup fails
        then perform a lookup:
            found_key == requested_key:
                HAM_FIND_EQ_MATCH: ok
                HAM_FIND_LT_MATCH: return move_prev()
                HAM_FIND_GT_MATCH: return move_next()
            found_key < requested_key:
                HAM_FIND_LT_MATCH: ok
                HAM_FIND_GT_MATCH: return move_next()
                HAM_FIND_EQ_MATCH: key not found
            found_key > requested_key:
                HAM_FIND_GT_MATCH: ok
                HAM_FIND_LT_MATCH: return move_prev()
                HAM_FIND_EQ_MATCH: key not found
    o must work with transactions
    o do not store key flags; the caller has to compare the key
    o remove ham_key_set_intflags, ham_key_get_intflags, key->_flags (?)

. win32: need a release-v2.pl which fully automates the various release steps
    o delete all generated protobuf files
    o build for msvc 2008
    o run unittests for debug and release
    o run samples
    o delete all generated protobuf files
    o build for msvc 2010
    o run unittests for debug and release
    o run samples
    o build release package

. also remove locking from C# and Java APIs

------------------- idea soup ---------------------------------------------

o btree_impl_default::set_record: if the duplicate is LAST of the last key
    in the node then simply append the record and increase next_offset

o asynchronous prefetching of pages
    -> see posix_fadvice, libprefetch

o flush transactions in background (when the btree is concurrent)

o Improve leaf pages caching
    Store start/end key of each leaf page in a separate lookup table in order
    to avoid btree traversals. This could be part of the hinter.
  - one such cache per database
  - should work for insert/find/erase

o allow transactions w/o journal

o allow transactions w/o recovery

o when recovering, give users the choice if active transactions should be
    aborted (default behavior) or re-created
    o needs a function to enumerate them

o when flushing the Changeset: batch ALL changes for the WHOLE transaction,
    then flush all of them together. This way we can "merge" multiple changes
    for the same page.
    Also review the whole flush process - when not to log etc.
    - only 1 page affected: no need to log it because it is idempotent
    - freelist pages are always idempotent
    - more than 1 index page? not idempotent (most likely)
    - more than 1 blob page? not idempotent (maybe)
    o define a few benchmarks
    o be careful: if N operations are modifying the same changelog, and
        then #N+1 aborts then the aborting operation must NOT clear the
        changelog!

o A new transactional mode: read-only transactions can run "in the past" - only
    on committed transactions. therefore they avoid conflicts and will always
    succeed.

o changeset: instead of simply adding pages to the changeset, the caller
    could already specify whether this page needs logging or not;
    i.e. after freelist rewrite, the blob pages do not need logging if a
    blob is deleted  

o is there a way to group all changeset flushes of a Transaction into one
    changeset, and batch-commit multiple commits? that way we would avoid the
    frequent syncs and performance would be improved
    o would have to remove all of assert(changeset.is_empty())
    o but we can use that assert prior to txn_begin

o flush in background (asynchronously)
    o need new flag file HAM_DISABLE_ASYNCHRONOUS_FLUSH
    o if in-memory database: disable async flush
    o if transactions are disabled: disable async flush
    o if enabled: create background thread, wait for signal
    o ham_env_flush: if txn are enabled then try to flush them to disk
    o how to deal with an error in the background thread???
        o store in Environment, then return in every exported function
    o default: async flush is OFF!

    o extend monster tests
        o with async flush
        o without async flush
        o extend/run performance test
        o run monster tests

    o documentation
        o tutorial
        o faq

o need a function to get the txn of a conflict (same as in v2)
    ham_status_t ham_txn_get_conflicting_txn(ham_txn_t *txn, ham_txn_t **other);
        oder: txn-id zurÃ¼ckgeben? sonst gibt's ne race condition wenn ein anderer
        thread "other" committed/aborted
    o also add to c++ API
    o add documentation (header file)
    o add documentation (wiki)

. new test case for cursors
    insert (1, a)
    insert (1, b) (duplicate of 1)
    move (last) (-> 1, b)
    insert (1, c)
    move (last) (-> 1, c)? is the dupecache updated correctly?

. there are a couple of areas where a btree cursor is uncoupled, just to
    retrieve the key and to couple the txn-key. that's not efficient
        db.c:__btree_cursor_points_to
        db.c:__compare_cursors
        txn_cursor.c:cursor_sync
        txn_cursor.c:cursor_overwrite
    o move to a separate function
    o try to optimize

. add tests to verify that the cursor is not modified if an operation fails!
    (in cursor.cpp:LongTxnCursorTest are some wrapper functions to move or
    insert the cursor; that's a good starting point)

. new flag for transactions: HAM_TXN_WILL_COMMIT
    if this flag is set, then write all records directly to the file, not
    to the log. the log will only contain the rid.
    -> or: make this the default; call the new flag HAM_TXN_MAYBE_WILL_ABORT
    o in case of an abort: move the record to the freelist
    -> this affects all temporary ham_insert-transactions
    (not sure if this should get high priority)

. if memory consumption in the txn-tree is too high: flush records to disk
    (not sure if this should get high priority)

o ham_get_count: could be atomically updated with every journal entry

=======
>>>>>>> Updated TODO
