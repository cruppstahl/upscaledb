I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

-----------------------------------------------------------------------------
This Branch Is About Integrating The hamsterdb2 Functionality!!!!!
-----------------------------------------------------------------------------
The big headline is:
As a user i want to run many Transactions in parallel with high performance.
I'm using multiple threads b/c my CPU has multiple cores, and expect hamsterdb
to scale with the number of cores.
==============================================================================

high-level plan for 2.1.7 pro ..............................................
x hamsterdb pro: compression for journal
x hamsterdb pro: compression for records
x hamsterdb pro: aes encryption
x hamsterdb pro: compression for keys
x hamsterdb: linear searches
x hamsterdb: upgrade libuv
x hamsterdb pro: SIMD instructions
o hamsterdb pro: 30 day evaluation

high-level plan for 2.1.8 ..................................................
o hamsterdb-pro: improve SIMD
o hamsterdb: more quickcheck tests
o hamsterdb: code cleanups
o hamsterdb: performance improvements for remote
o hamsterdb: improve page splits
o hamsterdb: delta updates



o web-page requires updates
    x deployed html differs from git-repository
    x download/sources: add erlang, remove 1.x
    x www1-repository and hamsterdb-www should be identical
        x updates for 2.1.6 are missing
        x samples fehlen
        x doku fehlt
        x download-dateien fehlen
    x www1
        x www1 and www2 are already combined in a single remote target
        x where to host static files? - hetzner server
        x clean up 'dl' directory
    x webpage copyright is still 2013
    o hamsterdb.com has read-only access to git repository, can do "git pull"
        for deployment
        "deploy" -> openshift, dann auch hamsterdb.com
================
        "staging" -> staging.hamsterdb.com
        auf dem server noch fertig einrichten
================

    o same for staging.hamsterdb.com, but uses the staging-branch
    o merge all repositories (host on github, keep remote branch)
        hamsterdb-www is the main repository, master pushes to staging
        'stable' pushes to hamsterdb.com, www1, www2

x PRO: enable zlib/snappy/others compression for the records
    x add documentation to header file
    x db: add record compression parameter
        x when creating a database
        x when opening a database
    x create compressor in database (w/ autoptr)
    x refactor BlobManager: should have common functionality, subclasses
            implement do_overwrite, do_allocate etc
        x move parameter checks and duplicate code to parent class
        x do not allow partial updates if compression is enabled
            x unittests
    x implement the actual compression/decompression
        x for in-memory AND disk
        x compression: store flag in BlobHeader
        x only compress if compressed size < original size
        x directly uncompress into output buffer,
            not in internal buffer of the compressor
            (or into user allocated buffer)
        x add unittests (disk and inmemory)
    x add parameters to ham_bench
    x add perftests, monster tests

x PRO: should journal and record compression settings really
    be non-persistent?
    -> should be persistent, makes things easier
    x journal compression: store in env-header
        x env-header has 2 reserved bytes, use them for compression
    x journal compression: disallow in ham_env_open
        x unittest
    x record compression: store in db-header
        x BtreeHeader has 2 bytes reserved for padding, use them for compression
    x record compression: disallow in ham_env_open_db
        x unittest
    x support ham_env_get_parameters
        x unittest
    x support ham_db_get_parameters
        x unittest
    x fix ham_bench
    x add ham_*_get_parameters to header documentation
    x fix memory leaks in unittests

x PRO: is able to open APL files, but not vice versa
    x use msb in file version for a marker
    x when loading a APL file in PRO: set the flag, write back
    x APL will automatically reject the file
    x ham_info: show whether db is pro
    x ham_info should print compression information
    x make ham_info a 100% user of the public API; do not access
        internal classes!

x do we really need the compression LEVEL parameters? if not then we can
    store the key compression flags very conveniently. otherwise we
    need extra storage! - no, remove it

x PRO: work over the license agreement; PRO will be similar to an NDA

x PRO: heavyweight compression for keys
    -> support compression with lzf and the other libraries
    -> keys are stored compressed IF the compressed keys are smaller than the
        uncompressed keys
    -> key->size in the node is the compressed size, and it might further
            be extended! the uncompressed size is part of the payload (16bit
            at the front)
    x need new parameters; store persistently
    x compress before inserting
        x only compress if the compressed size < uncompressed size
        x store the uncompressed size up-front
    x uncompress in get_key(), get_key_direct(), compare() etc
    x add unittests in combination with record encryption (w/ different
        algorithms)
    x what if a PAX layout is selected? -> return an error
        x add unittest
    x extend ham_info
    x add new option to ham_bench
    x add to dotnet wrapper
    x add to java wrapper
    x add to erlang wrapper
    x ham_bench: accept string parameters when enabling compression
    x metrics: track number of compressed and uncompressed keys
        x for journal compression
        x for record compression
        x for key compression
        x print in ham_bench
    x bugs raus

    x blob mgr: do not compress extended keys if the keys are already compressed
    x add header file documentation
    x add to monster and perftests
        x also test in combination with extended keys (very low threshold)
        x also test in combination with encryption and record compression
        x also test in-memory compression (keys + records)
    x unittest: key/record compression with user_alloc
    x fix TODOs in btree_impl_default.h
    x run the full monster suite

x PRO: if a compressor does not exist then ham_env_create_db should immediately
    return an error (this is currently not the case)
    x unittest

x use linear search for PAX (see topic/linear), but improve the
    performance!

x run benchmark with this:
    -mfpmath=sse -Ofast -flto -march=native -funroll-loops
    -> add recommendation to Performance documentation

x performance question: running ham_bench with 10mio keys (uint32, no records)
    and then performing --open --find-pct=100 -> 6.5 sec;
    with --cache=unlimited -> 6.5 sec
    why is there no difference? this is random access, and pages should be
    purged frequently. disabling mmap does not make a difference (SSD!).
    -> try with a spinning disk (same result)
    -> since this is a pure read-only workload, the pages are not modified
        and purging them does not have any I/O costs associated. Fetching them
        simply returns a pointer to the mmapped storage.
        disabling mmap becomes very costly, though.

x PRO: use SIMD instructions for the linear search
    -> SSE2 only supports comparisons for signed integers!
    x configure switch --enable-sse2: adds -msse2 to CFLAGS
        x enable by default if `grep /proc/cpuinfo sse2` != 0
    x need to figure out whether the CPU supports SSE/SSE2 (also on Windows)
        http://stackoverflow.com/questions/6121792/how-to-check-if-a-cpu-supports-the-sse3-instruction-set
    x metrics: add flag whether sse2 is supported
    x need unittest: if sse is enabled and supported then perform an
        sse comparison
    x rewrite configure settings
        x a generic enable/disable SIMD option
        x if enabled: use avx if available; otherwise fallback to sse2
    x metrics should return the LANE width, not bools (default is 0)

    o replace linear search with the SSE2 variant
        x move SSE-related code to a template function in simd.h
        x simd available? -> the find function calls the function in simd.h
            x if HAM_ENABLE_SIMD is true
            x if os_get_simd_lane_width() > 1
        x if threshold is reached: continue with linear search
            x the linear search implementation is not working identically to
                the SIMD functions; add unittest (i.e. for signed int)
                -> no, it's ok
            x threshold depends on supported instruction set (AVX, SSE2)
            x implement linear search with SIMD (SSE - 4x4)
                -> only for exact searches!
                x ham_u16_t
                x ham_u32_t
                x float
                x ham_u64_t
                x add unittests for sse
            x revert support for AVX (move to branch)
            x currently crashing or failing in debug build
            x then perform another round of profiling (with different
                    thresholds!)
=====================================
currently, the SSE2 version of ham_uint32_t is a bit SLOWER than the
regular version
-> check with a profiler
-> also check the linear search

x w/o SIMD: improved binary search
x w/o SIMD: find optimal linear search threshold
x w/ SIMD: improve uint32 
x w/ SIMD: improve uint16 
o w/ SIMD: improve uint64 
o w/ SIMD: improve float 
o w/ SIMD: improve double 
====>> Änderungen in APL-Version übertragen?
x get_record ist tief verschachtelt, nicht inline
=====================================
            x how to dispatch the function for AVX?
            o implement linear search with SIMD (AVX - 8x4?)
                really required?
                o ham_u16_t
                o ham_u32_t
                o float
                o ham_u64_t
                o double
                x add unittests for avx
            o all monster tests must be working
    x ham_bench: add flag to disable simd
    x review the changes - some can maybe be ported back to hamsterdb (APL)?
        -> find_exact!
    x test compilation with clang
    x add monster tests
    x add performance tests for all types (no records, many finds, with
        and without SSE)
    o run monster tests
    o test compilation with msvc
    o add monster tests
    o add performance tests for all types (no records, many finds, with
        and without SSE)

o performance question: running ham_bench with 10mio keys (uint32, no records)
    and then performing --open --find-pct=100 -> 6.5 sec;
    with --cache=unlimited -> 6.5 sec
    why is there no difference? this is random access, and pages should be
    purged frequently. disabling mmap does not make a difference (SSD!).
    -> try with a spinning disk
>>>>>>> a2464fe... SIMD preparations

o port everything to MacOS
o port everything to Win32/Visual Studio

o port everything to MacOS
o port everything to Win32/Visual Studio

o PRO: 30 day evaluation library
    x remove the ham_get_license() API - it doesn't make sense and people
        will not use it anyway
        x also from erlang
    x ham_time_t ham_is_pro_evaluation(); -> returns end time, or 0
    x insert 30 day trial check macros at various positions
        x insert code in
            x ham_env_create
            x ham_env_open
            x LocalDatabase::create
            x LocalDatabase::open
            x flushing transactions
            x accepting remote connections
        x implement with static functions and boost::posix_time::second_clock, 
            boost::posix_time::microsec_clock, time(0)
        x don't hardcode the timestamp but use a simple calculation, i.e.
                (1396600000+2536), 0x533e76a8, 012317473250 etc
            x return in ham_is_pro_evaluation()
    x needs different licensing output in the tools (evaluation - XX days left)
    x print message to stdout in ham_env_create, ham_env_open
        x make sure that all strings are obfuscated!
    x need a license agreement similar to an NDA
<<<<<<< HEAD
    x evaluate source obfuscators
    o prepare code for obfuscator, improve obfuscation with perl-scripts
=======
    o evaluate source obfuscators
        sourceformat - http://www.sourceformat.com
        Stunnix - http://www.stunnix.com/prod/cxxo/pricing.shtml
        Mangle-It - http://www.brothersoft.com/mangle-it-c%2B%2B-obfuscator-91793.html
        Semantic Design - http://www.semdesigns.com/Purchase/
        o also test the performance of the generated code!
>>>>>>> Updated TODO
    o create one source/win32 package starting at each week, running 30 days,
        for at least 3 months
        o requires a build tool for unix and win32
        o on windows only build the DLLs (32bit, 64bit with msvc2010,
                ham_bench for 32bit, ham_bench for 64bit),
              o then run a quick test (subset of the unittests)
              o and also check ham_is_pro_evaluation(), ham_is_pro()
        o use source obfuscator
    o create automagically in release-build.pl

o PRO: extend release-tool
    x new switch --product=apl|pro (default: apl)
    x for pro: use different version tag
    x for pro: use different packaging directory
    x for pro: use different file list
    x for pro: check dependencies (zlib, snappy, lzo, crypto)
    x for pro: add test for --disable-compression
    x for pro: add test for --disable-encryption
    x for pro: add test for --disable-simd
    o for pro: generate 30 day trials for the following 3 months,
        starting at every calendar week
        o for linux (obfuscated tar-balls)
        o for windows (precompiled 32bit and 64bit DLLs)

o PRO: additional stuff for the first release
<<<<<<< HEAD
<<<<<<< HEAD
    o update the ChangeLog (don't use a new one!)
    o update the README
=======
    o needs a ChangeLog
    o needs a README
>>>>>>> Updated TODO
=======
    o update the ChangeLog (don't use a new one!)
    o update the README
>>>>>>> Updated TODO

    x create new documentation page (wiki) for pro (tutorial + ham_bench)
        x journal compression
        x record compression
        x zlib compression
        x aes encryption
        x file compatibility
        x simd

    o need a database with commercial users
        o upgrade the current users
        o need a "download gate" api which verifies download links? or at
            least a script which generates those links
            -> the url is /download/pro/<hash>/<customer-id>/filename
            the hash is verified: md5sum(<customer-id> + filename + <salt>)
            if valid then download the file (and try to log via
            google analytics)

    o webpage
        x new marketing focus
        x feature matrix APL vs. closed source
        x new layout
        o daily backups of the mysql database
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> Updated TODO
        o request evaluation version: similar to contact form with additional
            details about the product; also has to sign off (= checkbutton)
            the evaluation license agreement

    o send email to all customers (add this to the release process)
        -> needs a link generator!
<<<<<<< HEAD
=======
        o publish benchmark against leveldb (with and without SSD)
            - each with 10 mio keys
            o uint32, small records, random write
            o uint32, small records, linear write
            o uint32, small records, random read
            o uint32, small records, linear read
            o bin16, default records, random write (w/o compression)
            o bin16, default records, linear write (w/o compression)
            o bin16, default records, random read (w/o compression)
            o bin16, default records, linear read (w/o compression)
            o bin16, default records, random write (w/ compression)
            o bin16, default records, linear write (w/ compression)
            o bin16, default records, random read (w/ compression)
            o bin16, default records, linear read (w/ compression)
>>>>>>> Updated TODO
=======
>>>>>>> Updated TODO

------------- first release of hamsterdb-pro 2.1.7 --------------------------

o remote code: get rid of protocol buffers (but leave them in the server
    for other languages). they are too expensive.
    x write a code generator which creates serialize/deserialize routines
        for the messages 
    x perform a benchmark - looks good, nearly 50% faster
    o port all functions
    o investigate libuv memory leaks reported by valgrind

o default layout: the lookup operations are relatively slow compared to PAX;
    can we somehow improve this?
    o run profiling on a read-only workload, w/o records

o make better use of mmapped memory
    x if file is created: can mmap be used? - no, only if an initial size
        is specified!
    x if file grows: can mmap be used? - yes, but the old mapping has to
        be unmapped, which means that all pointers become invalid. OR
        the page grows by a large amount, and creates a second mapping
    o in DiskBlobManager::fetch: check if address is in mapped area;
        if yes, then directly return a pointer (no memcpy)
        o but not if file is encrypted
        o also be careful with compression
            o this needs new tests! open an existing file with compressed
                records
    o check performance tests

o look into hive-integration
    -> would be an interesting market with requirements for column store
        storage
    -> how does the integration look like?
    -> has TPC-benchmarks and other benchmarks ready
    o write down everything i find, collect information and estimate
        efforts/gains (will do the same for mysql, R and mongodb later); this
        task is not about writing code!

o clean up globals; currently, many metrics and test gates are stored
    in global variables. collect them and store them in a struct Globals
    (globals.h).

o remove os.h, split to file.h and socket.h; file handle/socket handle
    will become a class member (including the win32 mmap handle). No longer
    directly access the file handles.
    All remaining functions are moved to the static class Os.

o QuickCheck: create a new property for testing duplicates; the key is always
    the same. The number of duplicate keys is tracked and periodically
    checked with the API. A cursor can be used to remove a specific
    duplicate, or to fetch a specific duplicate.

o do not purge pages if a cursor is attached
    o run performance tests

o insert: if HAM_HINT_APPEND is set then page splits should only create a
    new page, and not shifting any keys to the new sibling. only the new
    key is inserted in the new sibling.
    o run performance tests

o find a way how to execute user's code in the btree; similar to the hola
    core described below. we want to run analytical code in the lowest possible
    level, running on linear key data (thus being able to apply SIMD in the
    application)
    -> use a cursor; if a page does not have any pending transactional updates
        then iterate over the whole btree node (in the direction of the cursor),
        otherwise go step by step.
    => implement the following functions:
        ham_hola_count()
        ham_hola_count_if()
        ham_hola_count_distinct()
        ham_hola_count_distinct_if()
        ham_hola_average()
        ham_hola_average_if()
        ham_hola_sum()
        ham_hola_sum_if()
    -> based on this design: come up with an experimental API which will
        become the hola core routine, similar to the "scan" API that was
        planned
    -> the user's callback/function object can then accumulate or collect
        records, whereas the actual record data is only fetched when requested
    -> users need to be aware that it's not allowed to call into hamsterdb
        during such a scan (would create a deadlock)
    -> scans "pick up" other processors and run them at once, on the same
        data
    -> like this? where is the "return" value of the processor? how to specify
            multiple processors?
        void ham_db_scan(ham_cursor_t *cursor,
                     ham_key_t *begin, // can be null
                     ham_key_t *end, // can be null
                     ham_processor_cb_t *processor,
                     void *context,
                     ham_u32_t flags);

o collect/publish benchmark against leveldb (with and without SSD)
    - each with 100k and 100m keys
    o uint64, small records, random write
    o uint64, small records, linear write
    o uint64, small records, random read
    o uint64, small records, linear read
    o bin16, default records, random write (w/o compression)
    o bin16, default records, linear write (w/o compression)
    o bin16, default records, random read (w/o compression)
    o bin16, default records, linear read (w/o compression)
    o bin16, default records, random write (w/ compression)
    o bin16, default records, linear write (w/ compression)
    o bin16, default records, random read (w/ compression)
    o bin16, default records, linear read (w/ compression)
    o uint64, calculate sum()
    o bin16, use count_if() of all keys with lsb == 1

o delta updates managed in the BtreeNode
    the operations are attached to the node, but as soon as the node
    is accessed for a lookup or a scan, or immediately before the node
    is flushed, the deltas are merged into the node. So far this does not
    sound too efficient, but the bulk updates in combination with the
    key compression (i.e. for prefix compression) will benefit a lot.

    Also, they are really required for concurrency and to allow multiple
    writers in parallel.

    x perform a benchmark/profiling: random inserts vs. ascending inserts;
        the difference should be caused by memcopy/memmove (is it?)
        x PAX
            -> absolutely worth the effort, about 60% are spent in memmove
        x Default
            -> also worth the effort, about 15% are spent in memmove

<<<<<<< HEAD
<<<<<<< HEAD
    o need a flag to disable DeltaUpdates
=======
    o need a flag to disable DeltaUpdates; run tests if they should be
        disabled by default
>>>>>>> Updated TODO
=======
    o need a flag to disable DeltaUpdates
>>>>>>> Updated TODO
        o add flag to ham_bench
    o rename TransactionOperation to DeltaUpdate, decouple code from txn
    o totally transparent to the caller, handled in the proxy
    o merge them when reading and flushing
    o requires_split() takes delta updates into account
    o only add deltas to leaf nodes; internal nodes have too many read
        operations and would anyway require immediate flushes
<<<<<<< HEAD
<<<<<<< HEAD
    o DeltaUpdate objects from a txn-flush should directly go down to
        the node (detach from txn, attach to node)
=======
    o DeltaUpdate objects from a txn-flush should immediately go down to
        the node
>>>>>>> Updated TODO
=======
    o DeltaUpdate objects from a txn-flush should directly go down to
        the node (detach from txn, attach to node)
>>>>>>> Updated TODO
    o make the merge algorithm as efficient as possible
        o sort deltas by key
        o first execute all 'erase' either against other deltas or against
            the node
        o then merge the remaining inserts
        o this needs lots of tests
    o now run tests: should every update be stored as a DeltaUpdate? If not
        then disable them by default, unless Transactions are used (and unless
        bulk updates are used)

o architecture for a new webpage
    o pick an awesome design
        i.e. similar to http://foundationdb.com, http://laravel.com,
        http://rethinkdb.com
    o come up with the full site structure/contents
    o pick a framework for routing and infrastructure (phalcon? laravel?)
    o page contents are written in markdown or
        reStructuredText (http://sphinx-doc.org/rest.html)
    o documentation comments are hosted on disqus
        o try to seamlessly integrate the doxygen documentation,
            the javagen documentation, the erlang docs and the .NET docs 
            (and whatever comes in the future)
        o keep the documentation in the source tree, not in -www?
    o blog comments are hosted on disqus, articles also use rest
    o Makefile converts markdown to html
    o Makefile can "scp -r" everything to the servers (staging or production)
    o client area with
        o authentication
        o collection of files
        o analytics (who downloads what and when?)
    o admin area with
        o authentication
        o customer database
        o implementing business processes
        o sending out release emails
        o importing new releases
        o etc

------------- hamsterdb 2.1.8 ---------------------------------------

. PRO: add avx support
<<<<<<< HEAD
o PRO: add sse support for real64

<<<<<<< HEAD
=======
------------- hamsterdb 2.1.8 ---------------------------------------

o PRO: add avx support
=======
>>>>>>> Updated TODO
o PRO: add sse support for real64

>>>>>>> Updated TODO
o PRO: bulk updates (really only for pro?)
    - require delta updates
    - give users API to allocate memory for keys/records
    - if user says that data is already sorted then do not re-sort
    - add those delta updates to the txn-trees or to the btree node,
        transfer ownership of the memory
    -> or are these "batched" updates, in combination with cache-oblivious
        btrees? the batched updates contain lists of structures with
        information about the update (i.e. insert, erase etc). internally,
        a cursor is used to perform the update. this would be fast and a
        relatively cheap way to perform multiple operations in one
        single transaction. and they would not require delta updates, but
        still provide real value.
<<<<<<< HEAD
<<<<<<< HEAD
    o also for remote, transfer in a single message
=======
    o also for remote
>>>>>>> Updated TODO
=======
    o also for remote, transfer in a single message
>>>>>>> Updated TODO
    o also for .NET
    o also for java
    o also for erlang

o PRO: prefix compression for variable-length keys
    ==> not efficient for random read/writes, but that's ok. linear scans
        and appends will nevertheless be fast. 
    ==> when performing bulk updates/batched updates, make sure that the
        page is compressed only once
    ==> only for leaf keys!? internal keys have too much "distance", and
        the decompression would require too much time
    ==> implement this as an "aspect" for the default-layout with
        variable-sized keys

    o if key is appended at the end: just write the delta
    o otherwise append a delta-update to the page, and "merge" all deltas
        before the page is flushed. This will improve performance for batched
        updates, since they will cause only one page compression for
        multiple updates.
    o however, it's tricky to figure out whether a node requires a split or
        not, since it requires a good estimate of the size for the new key 
    
    o full keys can be further compressed with lzf or lzo
    o key search: jumps from full key to full key; in between, there's a
        linear search for the key

o PRO: use grouped varints for compressing int32/int64, record IDs and
    duplicate tables
    -> the concept will be similar to prefix compression

<<<<<<< HEAD
<<<<<<< HEAD
------------- hamsterdb 2.1.9 ---------------------------------------

o use cache-oblivious b-tree layout
    -> http://supertech.csail.mit.edu/cacheObliviousBTree.html
    o see roadmap document for more information
    o this feature is *per database*
    o calculate number of reqd pages based on estimated keys from the user
    o make sure that this is not reverted when "reduce file size" feature
        (above) is enabled
    o the new pages are not managed by the freelist! therefore the freelist
        will not need any modifications
    o after resize: mmap the whole file area. this is actually important because
        mmap is much faster than r/w; but when the database is created, the
        original mapping already exists. therefore we might have to handle
        more than one mapping in the file
    o PRO? PageManager: when allocating a new page then use the distribution
        function to fetch a page from the reserved storage
    . try to batch allocations; when new pages are required then don't just
        allocate one but multiple pages (if the database is big enough)
        -> could create a second memory mapping for the next chunk

. binary search in the nodes: keep track of the last result, use this as
    a starting point? or use a weighted search with "hot spots" for the first
    few lookups? this would require tests with different lookup characteristics,
    i.e. zipfian instead of purely random. bad for benchmarking.
=======
o PRO: CRC32-checksums (as soon as the file format is updated)
    o SSE2 has support for a CRC32 checksum calculation

=======
>>>>>>> Updated TODO
------------- hamsterdb 2.1.9 ---------------------------------------
>>>>>>> Updated TODO

o use cache-oblivious b-tree layout
    -> http://supertech.csail.mit.edu/cacheObliviousBTree.html
    o see roadmap document for more information
    o this feature is *per database*
    o calculate number of reqd pages based on estimated keys from the user
    o make sure that this is not reverted when "reduce file size" feature
        (above) is enabled
    o the new pages are not managed by the freelist! therefore the freelist
        will not need any modifications
    o after resize: mmap the whole file area. this is actually important because
        mmap is much faster than r/w; but when the database is created, the
        original mapping already exists. therefore we might have to handle
        more than one mapping in the file
    o PRO? PageManager: when allocating a new page then use the distribution
        function to fetch a page from the reserved storage
    . try to batch allocations; when new pages are required then don't just
        allocate one but multiple pages (if the database is big enough)
        -> could create a second memory mapping for the next chunk

. binary search in the nodes: keep track of the last result, use this as
    a starting point? or use a weighted search with "hot spots" for the first
    few lookups? this would require tests with different lookup characteristics,
    i.e. zipfian instead of purely random. bad for benchmarking.

o QuickCheck: automatically test the recovery feature by invoking "crashes"

. collect file format updates
    o PageManager state: also store m_last_blob_page_id persistently
    o EnvHeader is completely full; add at least 8 bytes for flags + reserved
    o reserve CRC32 for each page

o PRO: CRC32-checksums (as soon as the file format is updated)
    o SSE2 has support for a CRC32 checksum calculation

o PRO: hot backups (vacuumizes to a different file)
    - copies the database file
    - if compaction is enabled: copies keys w/ iterator
        (later: performs bulk updates)
    - then applies all committed transactions to the other file
    --> think this through; how to deal with delta updates? -> merge them
        what if only a few databases should be backed up?
        what if i want to back up in a logical format (i.e. csv)?

o "hola" - olap functions that operate directly on the btree data
    -> see wiki
    -> see java8 stream API:
        http://download.java.net/jdk8/docs/api/java/util/stream/Stream.html
    -> see supersonic:
        https://code.google.com/p/supersonic/
    -> see fast bitmap indices
        http://code.google.com/p/lemurbitmapindex/
    o create a design
    o operations on compressed data (COUNT(), MIN(), MAX(), ...)?
    o use async operations or futures/promises

- bloom filter -> PRO
- concurrency -> PRO

o the bucket for concurrency TODOs
    o reduce the linked lists - they're hard to be updated with atomic
        operations
        o page
        o transaction and dependent objects
        o ...

    o come up with a list of all functions, define which locking operation
        is required; then review the code and make sure this will work
        o the environment configuration
        o the database configuration
        o the transaction tree handling
        o the page manager, the device and the cache
        o the btree
        o the btree nodes (i.e. extkeycache, compressor)

    o come up with a list of functions for which concurrency makes most sense
        - parallel lookups (using the same memory arena)
        - flushing transactions asynchronously
        - purging caches asynchronously
        - async. merging of delta updates
        - have concurrent lookups/find/inserts (with delta updates)
    o separate SMOs from the actual operation (#2)
        -> check the literature
        http://pdf.aminer.org/000/409/763/b_trees_with_relaxed_balance.pdf
        o move SMO operations to "the janitor" (btree_janitor.h)
    o the global environment-lock should go because it's expensive; rather
        increment an atomic latch, and refuse to close/erase the database as
        long as the latch is > 0 

. clean up approx. matching
    o ONLY for cursors
    o Flags: HAM_FIND_LT_MATCH | HAM_FIND_GT_MATCH | HAM_FIND_EQ_MATCH (default)
    o lookup: the cursor is coupled to the key, even if the lookup fails
        then perform a lookup:
            found_key == requested_key:
                HAM_FIND_EQ_MATCH: ok
                HAM_FIND_LT_MATCH: return move_prev()
                HAM_FIND_GT_MATCH: return move_next()
            found_key < requested_key:
                HAM_FIND_LT_MATCH: ok
                HAM_FIND_GT_MATCH: return move_next()
                HAM_FIND_EQ_MATCH: key not found
            found_key > requested_key:
                HAM_FIND_GT_MATCH: ok
                HAM_FIND_LT_MATCH: return move_prev()
                HAM_FIND_EQ_MATCH: key not found
    o must work with transactions
    o do not store key flags; the caller has to compare the key
    o remove ham_key_set_intflags, ham_key_get_intflags, key->_flags (?)

. win32: need a release-v2.pl which fully automates the various release steps
    o delete all generated protobuf files
    o build for msvc 2008
    o run unittests for debug and release
    o run samples
    o delete all generated protobuf files
    o build for msvc 2010
    o run unittests for debug and release
    o run samples
    o build release package

. also remove locking from C# and Java APIs

------------------- idea soup ---------------------------------------------

o btree_impl_default::set_record: if the duplicate is LAST of the last key
    in the node then simply append the record and increase next_offset

o asynchronous prefetching of pages
    -> see posix_fadvice, libprefetch

o Improve leaf pages caching
    Store start/end key of each leaf page in a separate lookup table in order
    to avoid btree traversals. This could be part of the hinter.
  - one such cache per database
  - should work for insert/find/erase

o allow transactions w/o journal

o allow transactions w/o recovery

o when recovering, give users the choice if active transactions should be
    aborted (default behavior) or re-created
    o needs a function to enumerate them

o A new transactional mode: read-only transactions can run "in the past" - only
    on committed transactions. therefore they avoid conflicts and will always
    succeed.

o need a function to get the txn of a conflict (same as in v2)
    ham_status_t ham_txn_get_conflicting_txn(ham_txn_t *txn, ham_txn_t **other);
        oder: txn-id zurückgeben? sonst gibt's ne race condition wenn ein anderer
        thread "other" committed/aborted
    o also add to c++ API
    o add documentation (header file)
    o add documentation (wiki)

. new test case for cursors
    insert (1, a)
    insert (1, b) (duplicate of 1)
    move (last) (-> 1, b)
    insert (1, c)
    move (last) (-> 1, c)? is the dupecache updated correctly?

. there are a couple of areas where a btree cursor is uncoupled, just to
    retrieve the key and to couple the txn-key. that's not efficient
        db.c:__btree_cursor_points_to
        db.c:__compare_cursors
        txn_cursor.c:cursor_sync
        txn_cursor.c:cursor_overwrite
    o move to a separate function
    o try to optimize

. add tests to verify that the cursor is not modified if an operation fails!
    (in cursor.cpp:LongTxnCursorTest are some wrapper functions to move or
    insert the cursor; that's a good starting point)

. new flag for Transactions: HAM_TXN_WILL_COMMIT
    if this flag is set, then write all records directly to the file, not
    to the log. the log will only contain the rid.
    o in case of an abort: move the record to the freelist
    -> this affects all temporary ham_insert-transactions
    (not sure if this should get high priority)
